<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proof of Emotion (PoE) Algorithm Tester</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            border: 2px solid #00ff00;
            padding: 20px;
            margin-bottom: 30px;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .section {
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid #00ff00;
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
        }
        
        .validator-card {
            background: rgba(0, 100, 0, 0.2);
            border: 1px solid #00aa00;
            margin: 10px 0;
            padding: 15px;
            border-radius: 3px;
        }
        
        .consensus-result {
            background: rgba(0, 255, 255, 0.1);
            border: 2px solid #00ffff;
            padding: 20px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .button {
            background: #004400;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            margin: 10px 5px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        .button:hover {
            background: #006600;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .log {
            background: #111;
            border: 1px solid #333;
            padding: 15px;
            margin: 10px 0;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
            border-radius: 3px;
        }
        
        .metric {
            display: inline-block;
            margin: 5px 10px;
            padding: 5px 10px;
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            border-radius: 3px;
        }
        
        .success { color: #00ff00; }
        .warning { color: #ffaa00; }
        .error { color: #ff4444; }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border: 1px solid #666;
            border-radius: 3px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ffaa00, #00ff00);
            transition: width 0.3s;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🧠 PROOF OF EMOTION (PoE) ALGORITHM</h1>
            <p>First Blockchain Consensus Based on Human Emotional States</p>
            <p><strong>EmotionalChain Network</strong> | Version 1.0.0</p>
        </div>

        <div class="section">
            <h2>🔗 Network Control Panel</h2>
            <button class="button" onclick="initializeNetwork()">Initialize PoE Network</button>
            <button class="button" onclick="registerValidators()">Register Validators</button>
            <button class="button" onclick="simulateRealData()">Simulate Real Biometric Data</button>
            <button class="button" onclick="runConsensus()">Run PoE Consensus</button>
            <button class="button" onclick="runStressTest()">Stress Test Network</button>
            <button class="button" onclick="clearLogs()">Clear Logs</button>
        </div>

        <div class="grid">
            <div class="section">
                <h3>📊 Active Validators</h3>
                <div id="validators-list">
                    <p class="warning">No validators registered yet</p>
                </div>
            </div>

            <div class="section">
                <h3>🧠 Latest Consensus</h3>
                <div id="consensus-display">
                    <p class="warning">No consensus calculated yet</p>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>📈 Network Statistics</h3>
            <div id="network-stats">
                <div class="metric">Active Validators: <span id="validator-count">0</span></div>
                <div class="metric">Total Stake: <span id="total-stake">0</span> EMOTION</div>
                <div class="metric">Consensus Rate: <span id="consensus-rate">0%</span></div>
                <div class="metric">Avg Network Stress: <span id="avg-stress">0%</span></div>
                <div class="metric">Avg Network Energy: <span id="avg-energy">0%</span></div>
                <div class="metric">Avg Network Focus: <span id="avg-focus">0%</span></div>
            </div>
        </div>

        <div class="section">
            <h3>📋 Network Activity Log</h3>
            <div id="activity-log" class="log">
                <p>System ready. Initialize network to begin...</p>
            </div>
        </div>
    </div>

    <script>
        // Import the PoE algorithm (in real Replit, this would be a proper import)
        class ProofOfEmotion {
            constructor() {
                this.name = "Proof of Emotion (PoE)";
                this.version = "1.0.0";
                this.consensusThreshold = 67;
                this.validationWindow = 300000;
                this.minValidators = 3;
                this.maxValidators = 21;
                
                this.validators = new Map();
                this.emotionalProofs = new Map();
                this.consensusHistory = [];
                
                this.log("🔗 Proof of Emotion (PoE) Algorithm Initialized");
            }

            log(message) {
                const logElement = document.getElementById('activity-log');
                const timestamp = new Date().toLocaleTimeString();
                logElement.innerHTML += `<br>[${timestamp}] ${message}`;
                logElement.scrollTop = logElement.scrollHeight;
                console.log(message);
            }

            async registerValidator(address, stake, biometricDevice) {
                if (stake < 10000) {
                    throw new Error("Minimum stake required: 10,000 EMOTION tokens");
                }

                const validator = {
                    address,
                    stake,
                    biometricDevice,
                    joinedAt: Date.now(),
                    reputation: 100,
                    totalBlocks: 0,
                    missedBlocks: 0,
                    authenticity: 0,
                    isActive: true
                };

                this.validators.set(address, validator);
                this.log(`✅ Validator ${address} registered with ${stake.toLocaleString()} EMOTION stake`);
                
                return validator;
            }

            async generateEmotionalProof(validatorAddress, biometricData) {
                const validator = this.validators.get(validatorAddress);
                if (!validator) {
                    throw new Error("Validator not registered");
                }

                const emotionalMetrics = this.calculateEmotionalMetrics(biometricData);
                const authenticityScore = this.calculateAuthenticity(biometricData);
                
                if (authenticityScore < 80) {
                    throw new Error("Biometric authenticity too low for consensus participation");
                }

                const proof = {
                    validator: validatorAddress,
                    timestamp: Date.now(),
                    heartRate: biometricData.heartRate,
                    hrv: biometricData.hrv || 0,
                    stressLevel: emotionalMetrics.stress,
                    energyLevel: emotionalMetrics.energy,
                    focusLevel: emotionalMetrics.focus,
                    authenticityScore,
                    stake: validator.stake,
                    biometricHash: this.hashBiometricData(biometricData),
                    signature: this.signEmotionalProof(validatorAddress, emotionalMetrics)
                };

                this.emotionalProofs.set(validatorAddress, proof);
                this.log(`📊 Emotional proof: ${validatorAddress} | Stress:${emotionalMetrics.stress}% Energy:${emotionalMetrics.energy}% Focus:${emotionalMetrics.focus}%`);
                
                return proof;
            }

            calculateEmotionalMetrics(biometricData) {
                const { heartRate, hrv, skinConductance, movement } = biometricData;
                
                let stress = 0;
                if (heartRate > 100) stress += 30;
                if (heartRate > 120) stress += 20;
                if (hrv < 20) stress += 25;
                if (skinConductance > 0.7) stress += 25;
                stress = Math.min(stress, 100);

                let energy = 50;
                if (heartRate > 80 && heartRate < 100) energy += 20;
                if (movement > 0.5) energy += 15;
                if (hrv > 40) energy += 15;
                energy = Math.min(energy, 100);

                let focus = 70;
                if (hrv > 30 && stress < 30) focus += 20;
                if (stress > 70) focus -= 30;
                if (movement < 0.2) focus += 10;
                focus = Math.max(0, Math.min(focus, 100));

                return { stress, energy, focus };
            }

            calculateAuthenticity(biometricData) {
                let authenticity = 100;
                
                if (biometricData.heartRate % 5 === 0) authenticity -= 10;
                
                if (biometricData.heartRate < 40 || biometricData.heartRate > 200) {
                    authenticity -= 30;
                }
                
                const expectedConductance = (biometricData.heartRate - 60) / 100;
                const conductanceDiff = Math.abs(biometricData.skinConductance - expectedConductance);
                if (conductanceDiff > 0.3) authenticity -= 15;

                return Math.max(authenticity, 0);
            }

            async calculatePoEConsensus(blockHeight) {
                const validProofs = this.getValidEmotionalProofs();
                
                if (validProofs.length < this.minValidators) {
                    throw new Error(`Insufficient validators for consensus. Need ${this.minValidators}, got ${validProofs.length}`);
                }

                const totalStake = validProofs.reduce((sum, proof) => sum + proof.stake, 0);
                
                let weightedStress = 0;
                let weightedEnergy = 0;
                let weightedFocus = 0;
                let weightedAuthenticity = 0;

                validProofs.forEach(proof => {
                    const weight = proof.stake / totalStake;
                    weightedStress += proof.stressLevel * weight;
                    weightedEnergy += proof.energyLevel * weight;
                    weightedFocus += proof.focusLevel * weight;
                    weightedAuthenticity += proof.authenticityScore * weight;
                });

                const agreementScore = this.calculateEmotionalAgreement(validProofs);
                
                const consensus = {
                    blockHeight,
                    timestamp: Date.now(),
                    networkStress: Math.round(weightedStress),
                    networkEnergy: Math.round(weightedEnergy),
                    networkFocus: Math.round(weightedFocus),
                    networkAuthenticity: Math.round(weightedAuthenticity),
                    agreementScore: Math.round(agreementScore),
                    participatingValidators: validProofs.length,
                    totalStake,
                    consensusReached: agreementScore >= this.consensusThreshold,
                    validatorProofs: validProofs.map(p => ({
                        validator: p.validator,
                        stress: p.stressLevel,
                        energy: p.energyLevel,
                        focus: p.focusLevel,
                        authenticity: p.authenticityScore,
                        stake: p.stake
                    }))
                };

                this.consensusHistory.push(consensus);
                
                this.log(`🧠 PoE Consensus Block ${blockHeight}:`);
                this.log(`   Network Emotional State: Stress:${consensus.networkStress}% Energy:${consensus.networkEnergy}% Focus:${consensus.networkFocus}%`);
                this.log(`   Agreement Score: ${consensus.agreementScore}% (Threshold: ${this.consensusThreshold}%)`);
                this.log(`   Consensus: ${consensus.consensusReached ? '✅ REACHED' : '❌ FAILED'}`);
                
                return consensus;
            }

            calculateEmotionalAgreement(proofs) {
                if (proofs.length < 2) return 100;

                let totalAgreement = 0;
                let comparisons = 0;

                for (let i = 0; i < proofs.length; i++) {
                    for (let j = i + 1; j < proofs.length; j++) {
                        const proof1 = proofs[i];
                        const proof2 = proofs[j];
                        
                        const stressSimilarity = 1 - Math.abs(proof1.stressLevel - proof2.stressLevel) / 100;
                        const energySimilarity = 1 - Math.abs(proof1.energyLevel - proof2.energyLevel) / 100;
                        const focusSimilarity = 1 - Math.abs(proof1.focusLevel - proof2.focusLevel) / 100;
                        
                        const combinedStake = proof1.stake + proof2.stake;
                        const avgSimilarity = (stressSimilarity + energySimilarity + focusSimilarity) / 3;
                        
                        totalAgreement += avgSimilarity * combinedStake;
                        comparisons += combinedStake;
                    }
                }

                return comparisons > 0 ? (totalAgreement / comparisons) * 100 : 0;
            }

            getValidEmotionalProofs() {
                const now = Date.now();
                const validProofs = [];

                this.emotionalProofs.forEach((proof, validator) => {
                    if (now - proof.timestamp <= this.validationWindow) {
                        const validatorData = this.validators.get(validator);
                        if (validatorData && validatorData.isActive) {
                            validProofs.push(proof);
                        }
                    }
                });

                return validProofs;
            }

            calculateValidatorReward(validatorAddress, consensus) {
                const validator = this.validators.get(validatorAddress);
                const proof = this.emotionalProofs.get(validatorAddress);
                
                if (!validator || !proof) return 0;

                let reward = 50;

                if (proof.stressLevel < 30) reward += 25;
                if (this.improvedNetworkHealth(proof, consensus)) reward += 100;
                if (proof.authenticityScore > 95) reward += 15;
                if (consensus.participatingValidators >= this.minValidators * 2) reward += 10;

                this.log(`💰 Validator ${validatorAddress} reward: ${reward} EMOTION tokens`);
                return reward;
            }

            improvedNetworkHealth(proof, consensus) {
                if (this.consensusHistory.length < 2) return false;
                
                const previousConsensus = this.consensusHistory[this.consensusHistory.length - 2];
                
                const wasLessStressed = proof.stressLevel < previousConsensus.networkStress;
                const hadMoreEnergy = proof.energyLevel > previousConsensus.networkEnergy;
                const wasBetterFocused = proof.focusLevel > previousConsensus.networkFocus;
                
                return (wasLessStressed && hadMoreEnergy) || wasBetterFocused;
            }

            hashBiometricData(data) {
                const dataString = JSON.stringify({
                    heartRate: data.heartRate,
                    hrv: data.hrv,
                    timestamp: data.timestamp
                });
                
                let hash = 0;
                for (let i = 0; i < dataString.length; i++) {
                    const char = dataString.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return hash.toString(16);
            }

            signEmotionalProof(validator, metrics) {
                return `poe_${validator}_${metrics.stress}_${metrics.energy}_${metrics.focus}_${Date.now()}`;
            }

            getNetworkStats() {
                const activeValidators = Array.from(this.validators.values()).filter(v => v.isActive);
                const recentConsensus = this.consensusHistory.slice(-5);
                
                return {
                    totalValidators: activeValidators.length,
                    totalStake: activeValidators.reduce((sum, v) => sum + v.stake, 0),
                    recentConsensusRate: recentConsensus.filter(c => c.consensusReached).length / Math.max(recentConsensus.length, 1) * 100,
                    averageNetworkStress: recentConsensus.reduce((sum, c) => sum + c.networkStress, 0) / Math.max(recentConsensus.length, 1),
                    averageNetworkEnergy: recentConsensus.reduce((sum, c) => sum + c.networkEnergy, 0) / Math.max(recentConsensus.length, 1),
                    averageNetworkFocus: recentConsensus.reduce((sum, c) => sum + c.networkFocus, 0) / Math.max(recentConsensus.length, 1)
                };
            }
        }

        // Global PoE instance
        let poe = null;
        let currentBlockHeight = 0;

        // UI Functions
        function initializeNetwork() {
            poe = new ProofOfEmotion();
            currentBlockHeight = 0;
            updateUI();
            poe.log("🚀 EmotionalChain network initialized with PoE consensus");
        }

        async function registerValidators() {
            if (!poe) {
                alert("Please initialize the network first!");
                return;
            }

            try {
                await poe.registerValidator("validator_alice", 15000, "FitbitDevice_001");
                await poe.registerValidator("validator_bob", 12000, "AppleWatch_002");
                await poe.registerValidator("validator_charlie", 20000, "SamsungWatch_003");
                await poe.registerValidator("validator_diana", 18000, "GarminWatch_004");
                await poe.registerValidator("validator_eve", 25000, "WhooprBand_005");
                
                updateValidatorsList();
                updateNetworkStats();
                poe.log("👥 All validators registered successfully");
            } catch (error) {
                poe.log(`❌ Error registering validators: ${error.message}`);
            }
        }

        async function simulateRealData() {
            if (!poe || poe.validators.size === 0) {
                alert("Please initialize network and register validators first!");
                return;
            }

            poe.log("📊 Simulating real biometric data from wearable devices...");

            // Simulate realistic biometric data with some variation
            const biometricDataSets = [
                {
                    validator: "validator_alice",
                    data: {
                        heartRate: 72 + Math.floor(Math.random() * 10),
                        hrv: 45 + Math.floor(Math.random() * 20),
                        skinConductance: 0.3 + Math.random() * 0.3,
                        movement: 0.1 + Math.random() * 0.2,
                        timestamp: Date.now()
                    }
                },
                {
                    validator: "validator_bob",
                    data: {
                        heartRate: 85 + Math.floor(Math.random() * 20),
                        hrv: 25 + Math.floor(Math.random() * 15),
                        skinConductance: 0.6 + Math.random() * 0.3,
                        movement: 0.3 + Math.random() * 0.3,
                        timestamp: Date.now()
                    }
                },
                {
                    validator: "validator_charlie",
                    data: {
                        heartRate: 68 + Math.floor(Math.random() * 8),
                        hrv: 55 + Math.floor(Math.random() * 15),
                        skinConductance: 0.2 + Math.random() * 0.2,
                        movement: 0.05 + Math.random() * 0.1,
                        timestamp: Date.now()
                    }
                },
                {
                    validator: "validator_diana",
                    data: {
                        heartRate: 78 + Math.floor(Math.random() * 12),
                        hrv: 38 + Math.floor(Math.random() * 18),
                        skinConductance: 0.4 + Math.random() * 0.2,
                        movement: 0.2 + Math.random() * 0.25,
                        timestamp: Date.now()
                    }
                },
                {
                    validator: "validator_eve",
                    data: {
                        heartRate: 65 + Math.floor(Math.random() * 15),
                        hrv: 48 + Math.floor(Math.random() * 22),
                        skinConductance: 0.25 + Math.random() * 0.25,
                        movement: 0.08 + Math.random() * 0.15,
                        timestamp: Date.now()
                    }
                }
            ];

            try {
                for (const dataset of biometricDataSets) {
                    await poe.generateEmotionalProof(dataset.validator, dataset.data);
                }
                
                updateValidatorsList();
                poe.log("✅ Real biometric data simulation completed");
            } catch (error) {
                poe.log(`❌ Error simulating biometric data: ${error.message}`);
            }
        }

        async function runConsensus() {
            if (!poe || poe.emotionalProofs.size === 0) {
                alert("Please simulate biometric data first!");
                return;
            }

            try {
                currentBlockHeight++;
                poe.log(`🔗 Running PoE consensus for block ${currentBlockHeight}...`);
                
                const consensus = await poe.calculatePoEConsensus(currentBlockHeight);
                
                // Calculate rewards
                const validators = Array.from(poe.validators.keys());
                for (const validator of validators) {
                    if (poe.emotionalProofs.has(validator)) {
                        poe.calculateValidatorReward(validator, consensus);
                    }
                }
                
                updateConsensusDisplay(consensus);
                updateNetworkStats();
                
                if (consensus.consensusReached) {
                    poe.log(`🎉 Block ${currentBlockHeight} successfully validated with PoE consensus!`);
                } else {
                    poe.log(`⚠️ Block ${currentBlockHeight} failed PoE consensus (${consensus.agreementScore}% < ${poe.consensusThreshold}%)`);
                }
                
            } catch (error) {
                poe.log(`❌ Consensus failed: ${error.message}`);
            }
        }

        async function runStressTest() {
            if (!poe) {
                alert("Please initialize the network first!");
                return;
            }

            poe.log("🚀 Starting PoE stress test - simulating 10 blocks...");
            
            for (let i = 0; i < 10; i++) {
                await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
                await simulateRealData();
                await runConsensus();
            }
            
            poe.log("🎯 Stress test completed!");
        }

        function clearLogs() {
            document.getElementById('activity-log').innerHTML = '<p>Logs cleared. System ready...</p>';
        }

        function updateValidatorsList() {
            if (!poe) return;
            
            const validatorsList = document.getElementById('validators-list');
            if (poe.validators.size === 0) {
                validatorsList.innerHTML = '<p class="warning">No validators registered yet</p>';
                return;
            }

            let html = '';
            poe.validators.forEach((validator, address) => {
                const proof = poe.emotionalProofs.get(address);
                const shortAddress = address.substring(0, 20) + '...';
                
                html += `
                    <div class="validator-card">
                        <strong>${shortAddress}</strong><br>
                        Stake: ${validator.stake.toLocaleString()} EMOTION<br>
                        Device: ${validator.biometricDevice}<br>
                        Status: <span class="success">Active</span>
                        ${proof ? `<br>Latest: Stress:${proof.stressLevel}% Energy:${proof.energyLevel}% Focus:${proof.focusLevel}%` : ''}
                    </div>
                `;
            });
            
            validatorsList.innerHTML = html;
        }

        function updateConsensusDisplay(consensus) {
            if (!consensus) return;
            
            const display = document.getElementById('consensus-display');
            const statusClass = consensus.consensusReached ? 'success' : 'error';
            const statusText = consensus.consensusReached ? 'REACHED' : 'FAILED';
            
            display.innerHTML = `
                <div class="consensus-result">
                    <h4>Block ${consensus.blockHeight} Consensus</h4>
                    <div class="metric">Status: <span class="${statusClass}">${statusText}</span></div>
                    <div class="metric">Agreement: ${consensus.agreementScore}%</div>
                    <div class="metric">Participants: ${consensus.participatingValidators}</div>
                    <br>
                    <div class="metric">Network Stress: ${consensus.networkStress}%</div>
                    <div class="metric">Network Energy: ${consensus.networkEnergy}%</div>
                    <div class="metric">Network Focus: ${consensus.networkFocus}%</div>
                    <div class="metric">Authenticity: ${consensus.networkAuthenticity}%</div>
                </div>
            `;
        }

        function updateNetworkStats() {
            if (!poe) return;
            
            const stats = poe.getNetworkStats();
            
            document.getElementById('validator-count').textContent = stats.totalValidators;
            document.getElementById('total-stake').textContent = stats.totalStake.toLocaleString();
            document.getElementById('consensus-rate').textContent = stats.recentConsensusRate.toFixed(1) + '%';
            document.getElementById('avg-stress').textContent = stats.averageNetworkStress.toFixed(1) + '%';
            document.getElementById('avg-energy').textContent = stats.averageNetworkEnergy.toFixed(1) + '%';
            document.getElementById('avg-focus').textContent = stats.averageNetworkFocus.toFixed(1) + '%';
        }

        function updateUI() {
            updateValidatorsList();
            updateNetworkStats();
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            document.getElementById('activity-log').innerHTML = '<p>🧠 Proof of Emotion (PoE) Algorithm Tester Ready</p><p>Click "Initialize PoE Network" to begin...</p>';
        });
    </script>
</body>
</html>